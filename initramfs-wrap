#!/usr/bin/env python3
import argparse
from glob import glob
import gzip
import logging
import os
import platform
import shutil
import subprocess
import tempfile

DEB2GNU = {
    'amd64': 'x86_64',
    'armel': 'arm',
    'arm64': 'aarch64',
}
DEB2QEMU = {
    'amd64': 'x86_64',
    'armel': 'arm',
    'arm64': 'aarch64',
}
DEB2CONSOLE = {
    'armel': '/dev/ttyAMA0',
    'arm64': '/dev/ttyAMA0',
}


def get_binfmt_misc_interpreter(arch):
    if platform.machine() == DEB2GNU.get(arch, arch):
        return None
    qemu_arch = DEB2QEMU.get(arch, arch)
    with open(f'/proc/sys/fs/binfmt_misc/qemu-{qemu_arch}') as fp:
        for line in fp:
            if line.startswith('interpreter '):
                return line[12:-1]
    raise Exception('/proc/sys/fs/binfmt_misc is not configured')


def extract_deb(chroot, deb):
    archives = os.path.join(
        chroot, 'var', 'cache', 'apt', 'archives')
    deb_path, = glob(os.path.join(archives, f'{deb}_*.deb'))
    subprocess.check_call(['dpkg', '-x', deb_path, chroot])


def run_in_chroot(chroot, cmd):
    env_path = os.environ['PATH']
    fakechroot = f'{chroot}/bin/fakechroot'
    libfakechroot, = glob(f'{chroot}/usr/lib/*/fakechroot/libfakechroot.so')
    args = [
        'sh',
        fakechroot,
        '-l', libfakechroot,
        'chroot',
        chroot,
        'fakeroot-sysv',
        '-i', '/fakeroot-state',
        '-s', '/fakeroot-state',
    ]
    args.extend(cmd)
    subprocess.check_call(args, env={
        **os.environ,
        'QEMU_LD_PREFIX': chroot,
        'PATH': f'{chroot}/sbin:{chroot}/bin:{env_path}',
        'DEBIAN_FRONTEND': 'noninteractive',
    })


def get_chroot_archive(arch, suite):
    return os.path.expanduser(f'~/.cache/initramfs-wrap/{arch}-{suite}.tar.gz')


def host_fakeroot_command(args):
    result = [
        'fakeroot',
        '-i', os.path.join(chroot, 'fakeroot-state'),
        '-s', os.path.join(chroot, 'fakeroot-state'),
    ]
    result.extend(args)
    return result


def debootstrap1(chroot, arch, suite, **kwargs):
    cache = os.path.expanduser('~/.cache/initramfs-wrap/debootstrap')
    os.makedirs(cache, exist_ok=True)
    include_packages = [
        'fakechroot',
        'fakeroot',
        'gdb',
        'iproute2',
        'less',
        'nano',
        'procps',
        'strace',
        'tmux',
    ]
    if arch != 'armel':
        include_packages.append('valgrind')
    include_packages = ','.join(include_packages)
    exclude_packages = ','.join((
        'binutils',
        'binutils-common',
        f'binutils-{DEB2GNU.get(arch, arch)}-linux-gnu',
        'iptables',
        'libbinutils',
        'login',
        'rsyslog',
        'tzdata',
    ))
    subprocess.check_call([
        'fakechroot',
        'fakeroot',
        '-s', os.path.join(chroot, 'fakeroot-state'),
        'debootstrap',
        f'--cache-dir={cache}',
        '--foreign',
        f'--arch={arch}',
        '--variant=minbase',
        f'--include={include_packages}',
        f'--exclude={exclude_packages}',
        suite,
        chroot,
    ])


def copy_qemu_user_static(chroot, arch, **kwargs):
    qemu_path = get_binfmt_misc_interpreter(arch)
    if qemu_path is not None:
        shutil.copy(qemu_path, chroot + qemu_path)


def extract_bootstrapping_tools(chroot, **kwargs):
    for package in ('libfakeroot', 'fakeroot', 'libfakechroot', 'fakechroot'):
        extract_deb(chroot, package)


def fixup_fakechroot(chroot, **kwargs):
    path = os.path.join(chroot, 'bin', 'fakechroot')
    with open(path, 'r+') as fp:
        content = fp.read()
        fp.truncate(0)
        fp.write(content.replace(
            'FAKECHROOT_DETECT=1 /bin/echo',
            'FAKECHROOT_DETECT=1 sh -c :'))


def get_exclude_paths(arch):
    return (
        '/usr/share/calendar',
        '/usr/share/doc',
        '/usr/share/info',
        '/usr/share/locale',
        '/usr/share/man',
        f'/usr/lib/{DEB2GNU.get(arch, arch)}-linux-gnu/gconv',
        f'/usr/lib/{DEB2GNU.get(arch, arch)}-linux-gnu/perl-base/unicore',
        '/usr/include/valgrind',
    )


def configure_dpkg_exclude(chroot, arch, **kwargs):
    config_path = os.path.join(chroot, 'etc', 'dpkg', 'dpkg.cfg.d', 'exclude')
    with open(config_path, 'w') as fp:
        for exclude_path in get_exclude_paths(arch):
            fp.write(f'path-exclude={exclude_path}/*\n')
        fp.write(f'path-exclude=*.a\n')


def prune_dpkg_exclude(chroot, arch, **kwargs):
    for exclude_path in get_exclude_paths(arch):
        if not os.path.isdir(f'{chroot}/{exclude_path}'):
            continue
        run_in_chroot(chroot, ['find', exclude_path, '-type', 'f', '-delete'])


def ldconfig_paths(chroot):
    return (
        '/sbin/ldconfig',
        '/sbin/ldconfig.REAL',
        os.path.join(chroot, 'etc', 'dpkg', 'dpkg.cfg.d', 'exclude-ldconfig'),
    )


def fake_ldconfig(chroot, **kwargs):
    ldconfig, ldconfig_real, dpkg_config_path = ldconfig_paths(chroot)
    with open(dpkg_config_path, 'w') as fp:
        fp.write(f'path-exclude={ldconfig}\n')
    run_in_chroot(chroot, ['mv', ldconfig, ldconfig_real])
    run_in_chroot(chroot, ['ln', '-s', '/bin/true', ldconfig])


def debootstrap2(chroot, **kwargs):
    run_in_chroot(chroot, ['/debootstrap/debootstrap', '--second-stage'])


def fixup_fakechroot_again(chroot, **kwargs):
    fixup_fakechroot(chroot, **kwargs)


def fixup_symlinks(chroot, **kwargs):
    ln = f'ln -fsT "$(readlink "$0" | cut -c{len(chroot) + 1}-)" $0'
    subprocess.check_call(host_fakeroot_command([
        'find',
        '.',
        '-lname', os.path.join(chroot, '*'),
        '-exec', 'sh', '-c', ln, '{}', ';',
    ]), cwd=chroot)


def archive_chroot(chroot, arch, suite, **kwargs):
    subprocess.check_call(host_fakeroot_command([
        'tar',
        '-C', chroot,
        '-czf', get_chroot_archive(arch, suite),
        '.',
    ]))


CHROOT_SEQUENCE = (
    debootstrap1,
    copy_qemu_user_static,
    extract_bootstrapping_tools,
    fixup_fakechroot,
    configure_dpkg_exclude,
    prune_dpkg_exclude,
    fake_ldconfig,
    debootstrap2,
    fixup_fakechroot_again,
    fixup_symlinks,
    archive_chroot,
)


def extract_chroot(chroot, arch, suite, **kwargs):
    subprocess.check_call([
        'fakeroot',
        '-s', os.path.join(chroot, 'fakeroot-state'),
        'tar',
        '-C', chroot,
        '-xzf', get_chroot_archive(arch, suite),
    ])


def extract_input_initramfs_fp(chroot, fp):
    orig = os.path.join(chroot, 'orig')
    os.makedirs(orig, exist_ok=True)
    args = host_fakeroot_command(['cpio', '-idv'])
    p = subprocess.Popen(args, stdin=subprocess.PIPE, cwd=orig)
    shutil.copyfileobj(fp, p.stdin)
    p.stdin.flush()
    retcode = p.wait()
    if retcode != 0:
        raise subprocess.CalledProcessError(retcode, args)


def extract_input_initramfs(chroot, input_initramfs, **kwargs):
    if input_initramfs is None:
        return
    with open(input_initramfs, 'rb') as fp:
        magic = fp.read(6)
        fp.seek(0)
        if magic[:2] == b'\037\213':
            with gzip.open(fp) as gzfp:
                extract_input_initramfs_fp(chroot, gzfp)
        elif magic == b'070701':
            extract_input_initramfs_fp(chroot, fp)
        else:
            raise Exception(f'{input_initramfs} is neither .gz nor .cpio file')


def configure_init(chroot, arch, **kwargs):
    console = DEB2CONSOLE.get(arch, '/dev/console')
    with tempfile.NamedTemporaryFile('w+') as fp:
        fp.write(f'''#!/bin/sh
mount -t devtmpfs devtmpfs /dev
mount -t proc proc /proc
mount -t sysfs sysfs /sys
stty -F {console} sane
exec setsid sh -c 'exec /bin/bash <>{console} 2>&1'
''')
        fp.flush()
        fp.seek(0)
        subprocess.check_call(host_fakeroot_command([
            'sh', '-c', 'cat >init && chmod 755 init',
        ]), stdin=fp, cwd=chroot)


def configure_root(chroot, **kwargs):
    shadow = os.path.join(chroot, 'etc', 'shadow')
    subprocess.check_call(host_fakeroot_command([
        'sed', '-i', r's/root:\*:/root::/', shadow,
    ]))


def configure_hostname(chroot, **kwargs):
    with open(os.path.join(chroot, 'etc', 'hostname'), 'w') as fp:
        fp.write('initramfs-wrap\n')


def add_extra_files(chroot, extra_files, **kwargs):
    if extra_files is not None:
        for spec in extra_files:
            src, dst = spec.split(':')
            real_dst = f'{chroot}{dst}'
            shutil.copyfile(src, real_dst)


def make_exclude_expr(arch, exclude):
    exclude_paths = [
        './fakeroot-state',
    ]
    qemu_path = get_binfmt_misc_interpreter(arch)
    if qemu_path is not None:
        exclude_paths.append(f'.{qemu_path}')
    if exclude is not None:
        exclude_paths.extend(exclude)
    return ' '.join(
        f'! -path \'{exclude_path}\''
        for exclude_path in exclude_paths)


def archive_output_img(path, exclude_expr):
    img_size = 1024 * 1024 * 1024
    img_fs = 'ext2'
    with open(path, 'wb') as fp:
        fp.truncate(img_size)
    tar_args = host_fakeroot_command([
        'sh', '-c', f'find . {exclude_expr} | tar -T - -c',
    ])
    tar = subprocess.Popen(tar_args, stdout=subprocess.PIPE, cwd=chroot)
    subprocess.check_call([
        'guestfish', '-a', path,
        'launch', ':',
        'part-disk', '/dev/sda', 'gpt', ':',
        'mkfs', img_fs, '/dev/sda1', ':',
        'mount', '/dev/sda1', '/', ':',
        'tar-in', '-', '/',
    ], stdin=tar.stdout)
    retcode = tar.wait()
    if retcode != 0:
        raise subprocess.CalledProcessError(retcode, tar_args)


def remove_valgrind_tools(chroot, arch, **kwargs):
    path = f'/usr/lib/{DEB2GNU.get(arch, arch)}-linux-gnu/valgrind'
    tool_patterns = [
        f'{path}/{name}-*-linux'
        for name in (
            'helgrind',
            'callgrind',
            'drd',
            'massif',
            'exp-sgcheck',
            'cachegrind',
            'exp-dhat',
            'lackey',
            'exp-bbv',
            'none',
        )
    ]
    run_in_chroot(chroot, [
        'bash',
        '-O', 'nullglob',
        '-c', 'rm -f ' + ' '.join(tool_patterns),
    ])


def remove_python_codecs(chroot, arch, **kwargs):
    gnu_arch = DEB2GNU.get(arch, arch)
    dynload = '/usr/lib/python3.7/lib-dynload'
    codec_glob = f'_codecs_*.cpython-37m-{gnu_arch}-linux-gnu.so'
    run_in_chroot(chroot, [
        'bash',
        '-O', 'nullglob',
        '-c', f'rm -f {dynload}/{codec_glob}'
    ])


def remove_apt(chroot, **kwargs):
    packages = [
        'adduser',
        'apt',
        'debian-archive-keyring',
        'libapt-pkg5.0',
        'libgnutls30',
        'libidn2-0',
        'libunistring2',
        'passwd',
    ]
    directories = [
        '/etc/apt',
    ]
    run_in_chroot(chroot, ['dpkg', '--purge'] + packages)
    run_in_chroot(chroot, ['rm', '-r'] + directories)


def remove_force(chroot, **kwargs):
    packages = [
        'libdb5.3',
        'libsqlite3-0',
    ]
    run_in_chroot(chroot, [
        'dpkg',
        '--purge',
        '--force-depends',
    ] + packages)


def remove_dpkg(chroot, **kwargs):
    packages = [
        'debconf',
        'dpkg',
    ]
    directories = [
        '/etc/dpkg',
        '/var/cache/debconf',
        '/var/lib/dpkg',
    ]
    run_in_chroot(chroot, [
        'dpkg',
        '--purge',
        '--force-remove-essential',
        '--force-depends',
    ] + packages)
    run_in_chroot(chroot, ['rm', '-r'] + directories)


def unfake_ldconfig(chroot, **kwargs):
    ldconfig, ldconfig_real, dpkg_config_path = ldconfig_paths(chroot)
    # dpkg_config_path is already removed by remove_dpkg
    run_in_chroot(chroot, ['mv', ldconfig_real, ldconfig])


def archive_output_initramfs(
        chroot, arch, output_initramfs, exclude, **kwargs):
    exclude_expr = make_exclude_expr(arch, exclude)
    if output_initramfs.endswith('.raw'):
        return archive_output_img(output_initramfs, exclude_expr)
    args = host_fakeroot_command([
        'sh', '-c', f'find . {exclude_expr} | cpio -o -H newc',
    ])
    p = subprocess.Popen(
        args, stdout=subprocess.PIPE, cwd=chroot)
    if output_initramfs.endswith('.gz'):
        fp = gzip.open(output_initramfs, 'wb', 1)
    else:
        fp = open(output_initramfs, 'wb')
    with fp:
        shutil.copyfileobj(p.stdout, fp)
    retcode = p.wait()
    if retcode != 0:
        raise subprocess.CalledProcessError(retcode, args)


INITRAMFS_SEQUENCE = (
    extract_chroot,
    extract_input_initramfs,
    configure_init,
    configure_root,
    configure_hostname,
    add_extra_files,
    remove_valgrind_tools,
    remove_python_codecs,
    remove_apt,
    remove_force,
    remove_dpkg,
    unfake_ldconfig,
    archive_output_initramfs,
)


def is_in_sequence(args_s, sequence):
    return args_s in (step.__name__ for step in sequence)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='Add debugging tools to initramfs')
    parser.add_argument('-a', required=True, help='Architecture')
    parser.add_argument('-c', help='Reuse an existing chroot')
    parser.add_argument(
        '-d', action='append', help='Extra files to package (SRC:DST)')
    parser.add_argument('-f', action='store_true', help='Ignore cached chroot')
    parser.add_argument('-i', help='Input initramfs')
    parser.add_argument(
        '-k', action='store_true', help='Keep intermediate chroot')
    parser.add_argument('-o', required=True, help='Output initramfs')
    parser.add_argument('-s', help='Step to execute')
    parser.add_argument('-u', help='Suite', default='testing')
    parser.add_argument('-v', action='store_true', help='Verbose output')
    parser.add_argument('-x', action='append', help='Extra paths to exclude')
    args = parser.parse_args()
    if args.v:
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)
    if args.c is None:
        chroot = tempfile.mkdtemp(prefix=f'debootstrap-{args.a}-')
        logging.info('[*] Created %s', chroot)
    else:
        chroot = args.c
        logging.info('[*] Reusing %s', chroot)
    try:
        if (args.f or
                is_in_sequence(args.s, CHROOT_SEQUENCE) or
                not os.path.exists(get_chroot_archive(args.a, args.u))):
            for chroot_step in CHROOT_SEQUENCE:
                if args.s is None or args.s == chroot_step.__name__:
                    logging.info('[*] %s', chroot_step.__name__)
                    chroot_step(
                        chroot=chroot,
                        arch=args.a,
                        suite=args.u,
                    )
        for initramfs_step in INITRAMFS_SEQUENCE:
            if args.s is None or args.s == initramfs_step.__name__:
                logging.info('[*] %s', initramfs_step.__name__)
                initramfs_step(
                    chroot=chroot,
                    arch=args.a,
                    suite=args.u,
                    input_initramfs=args.i,
                    output_initramfs=args.o,
                    extra_files=args.d,
                    exclude=args.x,
                )
    finally:
        if args.c is None and not args.k:
            logging.info('[*] Deleting %s', chroot)
            shutil.rmtree(chroot)
        else:
            logging.info('[*] Keeping %s', chroot)
